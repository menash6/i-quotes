import { createAsyncThunk, createSlice } from "@reduxjs/toolkit";
// import { useSelector } from "react-redux";

import { STATUS } from "../timers/timersSlice";

// import { fetchMusicFromFolder } from "./musicPlayerAPI";
import { fetchFilesFromFolder } from "../../firebase.js";
import { fileURLToPath } from "url";
const INITIAL_DEFAULTS = {
  musicVol: 0.1,
  filter: -1,
};

const initialState = {
  allMusicPlaylist: [],
  filteredPlaylists: [[], [], [], [], []],
  // fullMusicPaths: [],
  filter: INITIAL_DEFAULTS.filter,

  musicVol: INITIAL_DEFAULTS.musicVol,
  currentMusicIndex: 0,
  isLoading: true,
  statusMusic: "idle",
  statusPlayingMusic: STATUS.READY, //PLAYING, PAUSED, ENDED, READY
  isPlayingMusic: false,
  hasError: false,
};

// The function below is called a thunk and allows us to perform async logic. It
// can be dispatched like a regular action: `dispatch(incrementAsync(10))`. This
// will call the thunk with the `dispatch` function as the first argument. Async
// code can then be executed and other actions can be dispatched. Thunks are
// typically used to make async requests.

export const fetchAsyncMusic = createAsyncThunk("quotesPlayer/fetchMusic", async () => {
  const focusMusic = fetchFilesFromFolder("/music/focus");
  const nightMusic = fetchFilesFromFolder("/music/night");
  const upbeatMusic = fetchFilesFromFolder("/music/upbeat");
  const morningMusic = fetchFilesFromFolder("/music/morning");
  const mindfulnessMusic = fetchFilesFromFolder("/music/mindfulness");
  return Promise.all([morningMusic, focusMusic, upbeatMusic, nightMusic, mindfulnessMusic]);
});

export const musicPlayerSlice = createSlice({
  name: "musicPlayer",
  initialState,
  reducers: {
    restartQuotesAndMusic: (state, action) => {
      state.statusPlayingQuote = STATUS.READY;
      state.isPlayingMusic = false;
      // state.musicVol = INITIAL_DEFAULTS.musicVol;
      state.currentQuoteIndex = (state.currentQuoteIndex + 1) % state.filteredQuotes.length;

      // dispatch(setIsPlayingMusic(false));
      // dispatch(setStatusPlayingQuote(STATUS.READY));
      // dispatch(updateQuoteIndex()); //todo shuffle
    },
    setIsPlayingMusicAndQuotes: (state, action) => {
      // console.log("setIsPlayingMusicAndQuotes and payload is", action.payload);
      // console.log("typeof action.payload", typeof action.payload);
      if (action.payload === true) {
        // if (state.musicVol == 1) state.musicVol = 0.1;
        if (state.statusPlayingQuote === STATUS.PAUSED || state.statusPlayingQuote === STATUS.READY)
          // if ENDED do nothing

          state.statusPlayingQuote = STATUS.RUNNING;
      } //if paused
      if (action.payload === false) {
        if (state.statusPlayingQuote === STATUS.RUNNING) state.statusPlayingQuote = STATUS.PAUSED;
      }
      state.isPlayingMusic = action.payload;
    },
    setStatusPlayingQuote: (state, action) => {
      // if (action.payload === STATUS.ENDED) state.musicVol = 1;
      // if (action.payload === STATUS.RUNNING) state.musicVol = 0.2;

      state.statusPlayingQuote = action.payload;
    },

    setIsPlayingMusic: (state, action) => {
      if (action.payload === false) {
        // time to the the fade - if it is running...
      }
      state.isPlayingMusic = action.payload;
    },
    setFilter: (state, action) => {
      console.warn("setFilter" + action.payload);
      state.filter = parseInt(action.payload);
    },

    updateMusicIndex: (state) => {
      state.currentMusicIndex = (state.currentMusicIndex + 1) % state.fullMusicPaths.length;
      state.isPlayingMusic = true; //redundant
    },
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder

      .addCase(fetchAsyncMusic.pending, (state) => {
        state.statusMusic = "loading";
        console.log("loading Music");
      })
      .addCase(fetchAsyncMusic.fulfilled, (state, action) => {
        console.log("fulfilled MUSIC");

        // action.payload.forEach((playlist,index)=> playlist.map)
        for (let filter = 0; filter < action.payload.length; filter++) {
          state.filteredPlaylists[filter] = action.payload[filter].map((file) => {
            return { ...file, categories: filter.toString() };
          });
        }
        // state.filteredPlaylists = action.payload;

        state.allMusicPlaylist = state.filteredPlaylists.flat(1);

        // state.allMusicPlaylist = action.payload.flat(1); //all musicplaylists into one big playlist

        state.statusMusic = "loaded";
        console.log("ðŸš€ ~ .addCase ~ state.statusMusic", state.statusMusic);
      });
  },
});

export const {
  setIsPlayingMusicAndQuotes,
  skipForwardMusicIndex,
  skipBackMusicIndex,
  updateMusicIndex,
  setFilter,
  setSpeaker,
  // setIsPlayingQuote,
  setIsPlayingMusic,
  setIsIsAllSpeakers,
  setStatusPlayingQuote,
} = musicPlayerSlice.actions;

export const musicPlayerActions = musicPlayerSlice.actions;

export const selectMusicFilter = (state) => state.musicPlayer.filter;

export const selectStatusMusic = (state) => state.musicPlayer.statusMusic;

export const selectIsPlayingMusic = (state) => state.musicPlayer.isPlayingMusic;

export const selectAllMusicPlaylist = (state) => {
  return state.musicPlayer.statusMusic !== "loaded" ? [] : state.musicPlayer.allMusicPlaylist;
};
export const selectFilteredMusicPlaylist = (state) => {
  if (state.musicPlayer.statusMusic !== "loaded") return [];
  const currFilter = state.musicPlayer.filter;
  return currFilter === -1
    ? state.musicPlayer.allMusicPlaylist
    : state.musicPlayer.filteredPlaylists[currFilter];
};

export default musicPlayerSlice.reducer;
